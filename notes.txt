
Ideas for dirmi:

- Byte and character streams supported
- Custom annotation describes how other kinds of streams can be connected
- How about custom annotation which can describe how anything is relayed?
  Can @Remote be defined this way? @Stream?
- Custom annotation handler is just given a raw stream to play with. Default
  annotation is @Object, which creates a new Object stream.
- Perhaps session ID is passed to handler too? To keep things separate?

- Define @Idempotent annotation for method. If connection restored, this method
  can be re-executed automatically. When connection lost, remote objects might
  lose their lease and get collected. If remote object was obtained via an
  @Idempotent method, then remote object can be obtained again. To support
  this, the remote object needs to remember what object, method, and parameters
  were invoked to get itself. The root remote object is implicitly idempotent,
  and it can be restored without calling an @Idempotent method. If remote
  object was not obtained from an @Idempotent method (or it is not the root)
  then it cannot be restored and an exception must be thrown.

- Define a mechanism to invoke any remote method asynchronously and return a
  Future. Perhaps this is just a RemoteFuture that's passed in as a parameter?

- Support batch requests somehow.

- Define @Marshalled annotation for method. This provides MarshalledObject
  class loading behavior for all objects passed through method. Instead of a
  URL and separate server for class transfer, class data is trasferred over
  remote connection. Both client and server side of Remote interface must have
  @Marshalled annotation in order for this to function. For added protection,
  marshalling is off by default on client and server.

TODO:

- Implement heartbeat as "pong" instead. Send an async message to other side
  with max time to wait before reply. Actual delay is the minimum of this value
  and local max wait time. A global scheduled executor sends these messages.

- Support asynchronous messages with optional flow control specified by a "max"
  or "permits" parameter. Server sends back hidden asynchronous messages when
  methods have completed. Stub keeps internal count for each asynchronous
  method via a Semaphore.

- Global cleaner thread can send dispose messages asynchronously because flow
  control will limit traffic. Dispose messages need to be sent to a global
  executor to ensure that the cleaner doesn't get stuck.

